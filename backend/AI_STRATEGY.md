# 🤖 璀璨宝石宝可梦 - AI策略文档

## 概述

本文档详细说明游戏中3种不同难度AI的决策策略和行为模式。

---

## 🎮 AI难度等级

| 难度 | 名称前缀 | 定位 | 特点 |
|------|----------|------|------|
| **简单** | 机器人·初学者 | 新手陪练 | 随机但合法，表现不稳定 |
| **中等** | 机器人·训练家 | 挑战对手 | 有策略，稳定表现 |
| **困难** | 机器人·大师 | 高级对手 | 局势感知，价值评估 |

---

## 1️⃣ 简单AI - 初学者策略

### 核心思路
模拟新手玩家，随机选择但遵守游戏规则，缺乏长期规划。

### 决策流程

```
每回合决策：
  ├─ 40%概率：尝试买卡
  │   └─ 从所有买得起的卡中随机选一张
  │
  ├─ 30%概率：预购卡牌（如果预购区<3张）
  │   └─ 从场上可预购卡中随机选一张
  │
  └─ 其他情况：拿球
      ├─ 如果某颜色球≥4个：30%概率拿2个同色
      └─ 否则：拿3个不同颜色
```

### 拿球逻辑

```python
def _get_random_balls():
    可用颜色 = 球池中>0的颜色（不含大师球）
    
    if 可用颜色 ≥ 3:
        # 球充足
        if 存在某颜色≥4个 && random() < 0.3:
            return [该颜色, 该颜色]  # 拿2个同色
        else:
            return 随机选3个不同颜色
    else:
        # 球不充足
        return 所有可用颜色各1个
```

### 特点分析

**优点**：
- ✅ 遵守所有游戏规则
- ✅ 不会死锁（能拿所有5种颜色）
- ✅ 能完成游戏
- ✅ 适合新手陪练

**缺点**：
- ❌ 没有长期规划
- ❌ 不追求高分卡
- ❌ 不考虑资源积累
- ❌ 随机性强，表现不稳定

**适用场景**：
- 新手玩家练习
- 快速测试游戏流程
- 演示游戏规则

**预期表现**：
- 完成游戏：150-300回合
- 胜率：vs新手 40-50%

---

## 2️⃣ 中等AI - 训练家策略

### 核心思路
优先级明确，有基本战术，会根据场上情况做出合理决策。

### 决策流程（严格优先级）

```
每回合决策：

优先级1：买高分卡
  └─ 如果能买卡 && 最高分卡>0分
      → 买胜利点数最高的卡

优先级2：买便宜的卡（积累资源）
  └─ 如果能买卡
      → 买总成本最低的卡（获得永久球）

优先级3：智能拿球
  └─ 根据需求计算最需要的颜色
      → 拿需求最高的3种颜色

优先级4（兜底）：智能预购卡牌
  └─ 如果预购区<3张 && 球池无法满足
      → 使用性价比算法找最优卡预购（获得大师球+锁定目标）
```

### 智能拿球算法

```python
def _get_smart_balls():
    # 初始化需求统计
    ball_needs = {每种颜色: 0}
    
    # 分析场上所有卡牌
    for 场上每张卡:
        if 买不起这张卡:
            for 每种颜色:
                缺少量 = 卡成本[颜色] - 持有[颜色] - 永久球[颜色]
                需求权重[颜色] += 缺少量 × (卡分数 + 1)
                # 高分卡的需求权重更高
    
    # 选择需求最高的颜色
    按需求权重排序
    
    if 可用颜色 ≥ 3:
        return 需求最高的3种颜色
    else:
        return 所有可用颜色
```

**需求计算示例**：

```
场上卡牌：
  - 迷你龙(1VP): 黄3, 红2
  - 波波(0VP): 粉3

玩家持有：红1, 蓝1

计算需求：
  黄球需求 = 3 × (1+1) = 6  ← 高分卡，权重高
  红球需求 = 2 × (1+1) = 4
  粉球需求 = 3 × (0+1) = 3  ← 0分卡，权重低

→ 优先拿：黄、红、粉（按需求排序）
```

### 买卡策略

```python
def buy_card_strategy():
    可买卡 = 获取所有买得起的卡()
    
    # 策略1：有高分卡就买
    高分卡 = [c for c in 可买卡 if c.victory_points > 0]
    if 高分卡:
        return max(高分卡, key=lambda c: c.victory_points)
    
    # 策略2：买最便宜的卡（积累资源）
    return min(可买卡, key=lambda c: sum(c.cost.values()))
```

### 智能预购策略（性价比算法）

中等AI使用**综合性价比算法**来选择最优预购卡，考虑多个维度：

```python
def _find_best_card_to_reserve(game, player):
    """
    性价比算法：
    score = (VP权重 × 卡分数) + (等级奖励 × 等级) 
            + (球池奖励 × 可得性) - (球差惩罚 × 球差距)
    """
    
    for 每张场上卡:
        # 1. 计算球差距（还需要多少个球）
        球差距 = 0
        需要的球 = {}
        for 每种颜色:
            需要 = max(0, 卡成本[颜色] - 持有[颜色] - 永久球[颜色])
            球差距 += 需要
            if 需要 > 0:
                需要的球[颜色] = 需要
        
        # 2. 计算球池可得性
        球池可得性 = 0
        for 颜色, 需要量 in 需要的球.items():
            球池剩余 = 球池[颜色]
            if 球池剩余 > 0:
                # 可满足率 = min(需要, 可用) / 需要
                球池可得性 += min(需要量, 球池剩余) / 需要量
            else:
                球池可得性 -= 2.0  # 球池没有，严重扣分
        
        # 3. 计算综合分数
        score = (
            10 × (卡分数 + 1) +        # VP权重（+1避免0分卡被忽略）
            1 × 卡等级 +                # 等级奖励
            5 × 球池可得性 -            # 球池奖励
            2 × 球差距                  # 球差惩罚
        )
        
        # 4. 特殊加成
        if 球差距 <= 3:
            score += 8  # 接近可买，额外加分
        
        if 卡.有进化:
            score += 3  # 进化卡额外价值
    
    return 分数最高的卡
```

**算法特点**：
1. **不盲目** - 不盲预购牌堆顶，而是看清场上所有卡的性价比
2. **多维度** - 综合考虑分数、球差距、球池状态
3. **动态调整** - 球池状态变化时，预购目标也会变化
4. **智能兜底** - 球池耗尽时，找最划算的卡预购（获得大师球的同时锁定目标）

**性价比示例**：

```
场景：球池只剩 黄2, 粉1
玩家持有：红3, 蓝2
预购区：空

场上3张卡：
  卡A: 迷你龙(1VP, Lv1) - 需要黄3
        球差距=3, 球池有黄2 → 可得性=2/3=0.67
        score = 10×2 + 1×1 + 5×0.67 - 2×3 = 18.35
  
  卡B: 波波(0VP, Lv1) - 需要粉3
        球差距=3, 球池有粉1 → 可得性=1/3=0.33
        score = 10×1 + 1×1 + 5×0.33 - 2×3 = 6.65
  
  卡C: 火恐龙(3VP, Lv2) - 需要红8, 黄2
        球差距=7, 球池有黄2 → 可得性=2/9=0.22
        score = 10×4 + 1×2 + 5×0.22 - 2×7 = 29.1
  
→ 选择卡C（虽然球差大，但高分卡+进化价值高）
```

### 特点分析

**优点**：
- ✅ 有明确的战术目标
- ✅ 会根据场上情况调整策略
- ✅ 资源积累有规划
- ✅ 拿球有针对性
- ✅ 稳定的表现

**缺点**：
- ⚠️ 缺乏局势感知（不知道何时冲刺）
- ⚠️ 不会战术对抗（不卡对手）
- ⚠️ 价值评估较简单

**适用场景**：
- 熟练玩家对战
- 游戏逻辑测试（**推荐**）
- 平衡性验证

**预期表现**：
- 完成游戏：50-150回合
- 胜率：vs新手 70-80%, vs简单AI 60-70%

---

## 3️⃣ 困难AI - 大师策略

### 核心思路
局势感知 + 综合价值评估 + 战术对抗，能根据比分调整策略。

### 决策流程（智能判断）

```
每回合决策：

阶段1：局势评估
  ├─ 我的分数 >= 目标分数×80% → 接近胜利
  ├─ 领先者分数 = max(所有玩家分数)
  └─ 我与领先者的差距

阶段2：根据局势决策

如果接近胜利（冲刺阶段）：
  └─ 优先买≥2分的高分卡
      → 快速结束游戏

正常阶段：
  ├─ 评估所有可买的卡（综合价值）
  │   └─ 价值 = 分数×10 + 等级×2 + 永久球数×3
  │
  ├─ 战术预购（卡对手）
  │   └─ 找≥3分的高分卡，预购阻止对手拿
  │
  └─ 最优拿球
      └─ 与中等AI相同，但计算更精确

兜底策略：
  └─ 智能预购（性价比算法，但权重更倾向高分卡）
```

### 综合价值评估

```python
def _evaluate_best_card(cards):
    最佳分数 = -1
    最佳卡 = None
    
    for 卡 in cards:
        score = 0
        
        # 胜利点数权重最高
        score += 卡.胜利点数 × 10
        
        # 卡牌等级也重要（高级卡有更好的永久球）
        score += 卡.等级 × 2
        
        # 永久球的长期价值
        score += sum(卡.永久球数量) × 3
        
        if score > 最佳分数:
            最佳分数 = score
            最佳卡 = 卡
    
    return 最佳卡
```

**价值评估示例**：

```
比较两张卡：
  卡A: 迷你龙(1VP, Lv1, 粉1永久) 
       → score = 1×10 + 1×2 + 1×3 = 15
  
  卡B: 尼多娜(1VP, Lv2, 粉2永久)
       → score = 1×10 + 2×2 + 2×3 = 20
  
→ 选择卡B（虽然同分，但等级和永久球更好）
```

### 局势感知

```python
def is_close_to_win(my_points, goal):
    """判断是否接近胜利"""
    return my_points >= goal * 0.8

# 例如目标18分：
# - 14.4分以上 → 进入冲刺模式
# - 冲刺模式：只买高分卡(≥2VP)，快速结束
```

### 战术预购

```python
def _find_threat_card():
    """找到对对手威胁最大的卡牌"""
    场上卡 = 所有可预购的卡
    
    # 优先预购高分卡（阻止对手）
    高分卡 = [c for c in 场上卡 if c.victory_points >= 3]
    if 高分卡:
        return random.choice(高分卡)
    
    # 其次预购高级别卡
    高级卡 = [c for c in 场上卡 if c.level >= 2]
    if 高级卡:
        return random.choice(高级卡)
    
    return random.choice(场上卡)
```

### 特点分析

**优点**：
- ✅ 局势感知（知道何时冲刺）
- ✅ 综合价值评估（多维度考虑）
- ✅ 战术对抗（预购卡住对手）
- ✅ 最优决策
- ✅ 最快完成游戏

**缺点**：
- ⚠️ 对新手可能太强
- ⚠️ 策略复杂度高（但性能好）

**适用场景**：
- 高手玩家挑战
- 压力测试
- AI对战演示

**预期表现**：
- 完成游戏：30-100回合
- 胜率：vs新手 90%+, vs中等AI 60-70%

---

## 📊 三种AI对比总览

### 决策对比

| 决策类型 | 简单AI | 中等AI | 困难AI |
|----------|--------|--------|--------|
| **买卡** | 随机选择 | 高分优先→便宜卡 | 价值评估+局势感知 |
| **拿球** | 智能随机 | 需求导向 | 最优需求 |
| **预购** | 30%随机 | 有价值才预购 | 战术预购（卡对手） |
| **进化** | 能进化就进化 | 能进化就进化 | 能进化就进化 |
| **局势** | 无感知 | 无感知 | 冲刺阶段识别 |

### 性能对比

| 指标 | 简单AI | 中等AI | 困难AI |
|------|--------|--------|--------|
| **平均回合数** | 150-300 | 50-150 | 30-100 |
| **策略复杂度** | ⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **决策质量** | 随机 | 稳定 | 最优 |
| **资源效率** | 低 | 中 | 高 |
| **对新手胜率** | 40-50% | 70-80% | 90%+ |

### 代码复杂度

```
简单AI：~50行核心逻辑
中等AI：~100行核心逻辑
困难AI：~150行核心逻辑

共享辅助函数：~200行
```

---

## 🎯 使用建议

### 测试场景

```python
# 功能测试（推荐）
game = SplendorPokemonGame(["AI1", "AI2"], victory_points=15)
ai1 = AIPlayer("中等")  # 稳定可靠
ai2 = AIPlayer("中等")
```

```python
# 性能测试
game = SplendorPokemonGame(["AI1", "AI2"], victory_points=18)
ai1 = AIPlayer("困难")  # 快速完成
ai2 = AIPlayer("困难")
```

```python
# 规则验证
game = SplendorPokemonGame(["AI1", "AI2"], victory_points=10)
ai1 = AIPlayer("简单")  # 更多边缘情况
ai2 = AIPlayer("中等")
```

### 对战场景

```python
# 新手友好
玩家 vs AIPlayer("简单")

# 正常挑战
玩家 vs AIPlayer("中等")

# 高手对决
玩家 vs AIPlayer("困难")

# AI对战演示
AIPlayer("中等") vs AIPlayer("困难")
```

### 平衡性调整

如果发现AI太强或太弱，可以调整：

1. **调整概率**（简单AI）
   ```python
   # 提高买卡概率（变强）
   if buyable_cards and random.random() < 0.6:  # 从0.4改为0.6
   ```

2. **调整优先级**（中等AI）
   ```python
   # 更保守：降低高分卡阈值
   if best_card.victory_points > 1:  # 从>0改为>1
   ```

3. **调整局势阈值**（困难AI）
   ```python
   # 延迟冲刺：提高阈值
   is_close_to_win = my_points >= (goal * 0.9)  # 从0.8改为0.9
   ```

---

## 🔧 技术细节

### 共享辅助函数

所有AI共享这些辅助方法：

- `_get_buyable_cards()` - 获取所有可买的卡（场上+稀有+传说+预购区）
- `_can_afford()` - 检查是否买得起某张卡
- `_get_all_tableau_cards()` - 获取场上所有可预购的卡
- `_get_random_balls()` - 随机但合法地拿球
- `_get_smart_balls()` - 根据需求智能拿球
- `_find_valuable_card()` - 找有价值的卡用于预购

### 兜底机制

所有AI都有完善的兜底机制，确保不会卡住：

1. 优先尝试买卡
2. 其次尝试预购
3. 再次尝试拿球
4. 球池空了 → 盲预购（获得大师球）
5. 预购区满了 → 强制拿球或空过

### 规则遵守

所有AI严格遵守：

- ✅ 拿球规则（2同色需≥4，不足3种拿全部）
- ✅ 预购限制（最多3张，稀有传说不可预购）
- ✅ 球数上限（>10自动放回）
- ✅ 每回合必须执行一个动作

---

## 📝 维护日志

- **2025-10-16**: 创建初始版本
- 实现了3种难度的AI策略
- 经过测试，所有AI都能正常完成游戏

---

## 🔗 相关文件

- 实现代码：`backend/ai_player.py`
- 游戏逻辑：`cuicanbaoshi.py`
- 测试文件：`test_game_suite.py`
- 死锁问题分析：`SOLUTION_FOR_DEADLOCK.md`

